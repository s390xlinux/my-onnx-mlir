pipeline {
    options { skipDefaultCheckout() }

    agent {
        node {
            label 'master'
            /* Each pull request has its own build directory so concurrent builds
             * of different pull requests will not trash each other.
             */
            customWorkspace "${JENKINS_HOME}/workspace/${JOB_NAME}@pr_${ONNX_MLIR_PR_NUMBER}"
        }
    }

    /* Global environment variables */
    environment {
        /* params is a map object supplied by Jenkins */
        /* ONNX_MLIR_PR_NUMBER = "${params.getAt(params.keySet().getAt(0))}" */

        /* Each pull request will also get its own Jenkinsfile checkout directory.
	 * Jenkinsfile checkout always goes under ...@script so we configure the
	 * SCM in the web UI to use a subdirectory pr_### for each pull request.
	 */
	JENKINSFILE_DIR = "${JENKINS_HOME}/workspace/${JOB_NAME}@script/pr_${ONNX_MLIR_PR_NUMBER}"

        /* Payloads that are the same for all events */
	ONNX_MLIR_PR_ACTION = "${github_webhook_payload_action}"
	ONNX_MLIR_PR_SENDER = "${github_webhook_payload_sender_login}"
        ONNX_MLIR_PR_REPO_URL = "${github_webhook_payload_repository_clone_url}"

        /* Different GitHub events use slightly different payload data so we
	 * have to deal with that.
	 *
	 * Note that the push event from merging a PR is just a push on master
	 * branch and is not tied to the specific PR. Only the commit message
	 * indicates which PR is merged. So the commit message is used as the
	 * title. The push event also does not have its own statuses url since
	 * the PR is merged and closed. So the PR's statuses url will be used.
	 *
	 * Also note the escaped $ sign. It's first interpreted by Jenkins.
	 * So if we want bash specific interpretation such as $(git ...),
	 * we need to escape the $ sign.
	 */
        ONNX_MLIR_PR_STATUS_URL = sh(returnStdout: true, script: """#!/bin/bash +x
            url=${github_webhook_payload_repository_statuses_url}
            declare -A sha1=([pull_request]="\$(git -C ${JENKINSFILE_DIR} rev-parse HEAD)"
                             [issue_comment]="\$(git -C ${JENKINSFILE_DIR} rev-parse HEAD)"
                             [push]="${github_webhook_payload_commits_0_id}")
            echo \${url%\\{sha\\}}\${sha1[${x_github_event}]}""").trim()

        ONNX_MLIR_PR_REMOTE = sh(returnStdout: true, script: """#!/bin/bash +x
            declare -A remote=([pull_request]="origin"
                               [issue_comment]="origin"
                               [push]="")
            echo \${remote[${x_github_event}]}""").trim()

        ONNX_MLIR_PR_REFSPEC = sh(returnStdout: true, script: """#!/bin/bash +x
            declare -A refspec=([pull_request]="+refs/pull/*:refs/remotes/origin/pr/*"
                                [issue_comment]="+refs/pull/*:refs/remotes/origin/pr/*"
                                [push]="")
            echo \${refspec[${x_github_event}]}""").trim()

        ONNX_MLIR_PR_BRANCH = sh(returnStdout: true, script: """#!/bin/bash +x
            declare -A branch=([pull_request]="origin/pr/${ONNX_MLIR_PR_NUMBER}/head"
                               [issue_comment]="origin/pr/${ONNX_MLIR_PR_NUMBER}/head"
                               [push]="refs/heads/master")
            echo \${branch[${x_github_event}]}""").trim()

        /* Don't use WORKSPACE since source hasn't being checked out yet */
        ONNX_MLIR_PR_COMMIT_MESSAGE = sh(returnStdout: true, script: """#!/bin/bash +x
	    git -C ${JENKINSFILE_DIR} log --oneline --format=%B -n 1 HEAD""").trim()

        DOCKERHUB_USER_NAME = 's390xlinux'

        /* Credentials defined in Jenkins */
        JENKINS_REST_API_TOKEN = credentials('Jenkins-REST-API-Token')
        GITHUB_JENKINS_DROID_TOKEN = credentials('jenkins-buildbot-access-token')
        GITHUB_WEBHOOK_TOKEN = credentials('github-onnx-mlir-to-jenkins-gwt')
        DOCKERHUB_USER_TOKEN = credentials('jenkins-s390x-to-dockerhub-s390xlinux')
        GITHUB_COMMIT_STATUS_TOKEN = credentials('Github-Commit-Status-Token')

        /* External stage build scripts */
	STAGE_PRE_BUILD_SCRIPT="${JENKINSFILE_DIR}/.buildbot/stage-pre-build.py"
	STAGE_LLVM_PROJECT_SCRIPT="${JENKINSFILE_DIR}/.buildbot/stage-llvm-project.py"
	STAGE_ONNX_MLIR_SCRIPT="${JENKINSFILE_DIR}/.buildbot/stage-onnx-mlir.py"
	STAGE_POST_BUILD_SCRIPT="${JENKINSFILE_DIR}/.buildbot/stage-post-build.py"
    }
    
    stages {
        stage('Pre checkout actions') {
            steps {
	        /* uncomment for debugging */
                /*sh 'printenv'*/
		echo "${ONNX_MLIR_PR_NUMBER}"
		echo "${ONNX_MLIR_PR_TITLE}"
		echo "${ONNX_MLIR_PR_STATUS_URL}"
		echo "${ONNX_MLIR_PR_REPO_URL}"
		echo "${ONNX_MLIR_PR_REMOTE}"
		echo "${ONNX_MLIR_PR_REFSPEC}"
		echo "${ONNX_MLIR_PR_BRANCH}"
		call_build_script("${STAGE_PRE_BUILD_SCRIPT}")
		set_build_name("${x_github_event}")
                post_commit_status("${x_github_event}", 'pending')
            }
        }

        stage('Checkout PR source') {
            when { not { environment name: 'ONNX_MLIR_PR_ACTION',
                         value: 'closed' } }
            steps {
	        checkout_pr_source("${ONNX_MLIR_PR_REPO_URL}",
		                   "${ONNX_MLIR_PR_REMOTE}",
				   "${ONNX_MLIR_PR_REFSPEC}",
				   "${ONNX_MLIR_PR_BRANCH}")
            }
        }

        stage('Build llvm-project images') {
            when { not { environment name: 'ONNX_MLIR_PR_ACTION',
                         value: 'closed' } }
            steps {
                call_build_script("${STAGE_LLVM_PROJECT_SCRIPT}")
            }
        }
        
        stage('Build onnx-mlir images') {
            when { not { environment name: 'ONNX_MLIR_PR_ACTION',
                         value: 'closed' } }
            steps {
                call_build_script("${STAGE_ONNX_MLIR_SCRIPT}")
            }
        }
    }

    post {
        success {
            call_build_script("${STAGE_POST_BUILD_SCRIPT}")
            post_commit_status("${x_github_event}", 'success')
        }
        failure {
	    /* leave images and containers behind for debugging */
            post_commit_status("${x_github_event}", 'failure')
        }
        aborted {
            call_build_script("${STAGE_POST_BUILD_SCRIPT}")
            post_commit_status("${x_github_event}", 'aborted')
        }
    }
}

/* Set build name appearing on the build history */
def set_build_name(event) {
    def title = "${ONNX_MLIR_PR_TITLE}"
    def pr    = (event == 'pull_request') ? 'PR ' : 'pr '
    currentBuild.displayName = "#${BUILD_NUMBER} " + pr +
			       "#${ONNX_MLIR_PR_NUMBER} " +
                               "[${ONNX_MLIR_PR_SENDER}] " +
                               "[${ONNX_MLIR_PR_ACTION}] " +
                               title.substring(0,Math.min(title.length(),32)) +
                               (title.length() > 32 ? '...' : '')
}

/* Checkout pull request source */
def checkout_pr_source(url, remote, refspec, branch) {
    checkout([
        $class: 'GitSCM',
        userRemoteConfigs: [[ url: "${url}", name: "${remote}", refspec: "${refspec}" ]],
        branches: [[ name: "${branch}" ]],
        extensions: [
            [ $class: 'CloneOption', noTags: false, shallow: true ],
            [ $class: 'SubmoduleOption', recursiveSubmodules: true ],
            [ $class: 'CleanBeforeCheckout', deleteUntrackedNestedRepositories: true ]
        ]
    ])
}

/* Call external script */
def call_build_script(script) {
    sh "${script}"
}

/* Set commit status appearing on the GitHub pull request page */
def post_commit_status(event, state) {
    def status   = (state == 'aborted') ? 'failure' : state
    def arch     = sh(returnStdout: true, script: '''#!/bin/bash +x
                   uname -m''').trim().replace('x86_', 'amd')
    def title    = "${ONNX_MLIR_PR_COMMIT_MESSAGE}"
    def pr       = (event == 'pull_request') ? 'PR ' : 'pr '
    def desc     = "Build #${BUILD_NUMBER} " + pr + "#${ONNX_MLIR_PR_NUMBER} " +
                   title.substring(0,Math.min(title.length(),24)) + '...'
    def action   = (state == 'success') ? 'passed'  :
                   (state == 'failure') ? 'failed'  :
                   (state == 'aborted') ? 'aborted' : 'started'
    def start    = (new Date("${currentBuild.startTimeInMillis}".toLong())).format('HH:mm')
    def duration = (state == 'pending') ?
        "at ${start}" : "after ${currentBuild.durationString.replace(' and counting','')}"

    def data = """
        { "state": "${status}", \
          "context": "Jenkins Linux ${arch}", \
          "description": "${desc} ${action} ${duration}" }
    """

    sh '''#!/bin/bash +x
    curl -s ${ONNX_MLIR_PR_STATUS_URL} \
         -X POST \
         -H "Accept: application/vnd.github.v3+json" \
         -H "Authorization: token ${GITHUB_COMMIT_STATUS_TOKEN}" \
         -d \' ''' + data + ''' \' | \
    jq '{url: .url, state: .state, description: .description, context: .context}'
    '''
}
